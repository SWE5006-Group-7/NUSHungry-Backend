input {
  # TCP输入 - 接收来自微服务的JSON格式日志
  tcp {
    port => 5000
    codec => json_lines
    type => "microservice-logs"
  }

  # UDP输入 - 可选的轻量级传输
  udp {
    port => 5000
    codec => json_lines
    type => "microservice-logs"
  }

  # Beats输入 - 接收来自Filebeat的日志
  beats {
    port => 5044
    type => "filebeat-logs"
  }
}

filter {
  # 解析微服务日志
  if [type] == "microservice-logs" {
    # 添加服务名称字段（如果不存在）
    if ![service_name] {
      mutate {
        add_field => { "service_name" => "unknown" }
      }
    }

    # 添加时间戳（如果不存在）
    if ![timestamp] and [time] {
      mutate {
        rename => { "time" => "timestamp" }
      }
    }

    # 解析日志级别
    if [level] {
      mutate {
        uppercase => [ "level" ]
      }
    }

    # 添加环境标签
    mutate {
      add_field => { "environment" => "${ENVIRONMENT:dev}" }
      add_tag => [ "nushungry-microservice" ]
    }

    # 处理异常堆栈信息
    if [stack_trace] {
      mutate {
        add_tag => [ "has-exception" ]
      }
    }

    # Grok解析（如果是非JSON格式的日志）
    if "_jsonparsefailure" in [tags] {
      grok {
        match => {
          "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} \[%{DATA:service_name}\] %{GREEDYDATA:log_message}"
        }
      }
    }
  }

  # 解析Filebeat日志
  if [type] == "filebeat-logs" {
    # 提取Docker容器名称作为服务名
    if [container] and [container][name] {
      mutate {
        add_field => { "service_name" => "%{[container][name]}" }
      }
    }

    # 尝试解析JSON日志
    json {
      source => "message"
      target => "log"
      skip_on_invalid_json => true
    }
  }

  # 统一日期格式
  date {
    match => [ "timestamp", "ISO8601", "yyyy-MM-dd HH:mm:ss.SSS", "yyyy-MM-dd'T'HH:mm:ss.SSSZ" ]
    target => "@timestamp"
  }

  # 移除不需要的字段
  mutate {
    remove_field => [ "host", "agent", "ecs", "input" ]
  }
}

output {
  # 输出到Elasticsearch
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "nushungry-logs-%{+YYYY.MM.dd}"

    # 文档模板
    template_name => "nushungry-logs"
    template_overwrite => true
  }

  # 输出到控制台（调试用，生产环境可注释）
  stdout {
    codec => rubydebug {
      metadata => false
    }
  }
}
